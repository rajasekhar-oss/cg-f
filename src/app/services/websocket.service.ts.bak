

import { Injectable, OnDestroy } from '@angular/core';
import { Observable, Subject, BehaviorSubject } from 'rxjs';
import { Client, IMessage, Frame } from '@stomp/stompjs';
import { environment } from '../../environments/environment';
import { AuthService } from './auth.service';
import { RoomInfoDto, GameStateDto } from '../models/backend.types';
import { TopicType, WebSocketEvent, WebSocketSubscription } from '../models/websocket.types';



@Injectable({ providedIn: 'root' })
export class WebsocketService implements OnDestroy {
  private stompClient: Client | null = null;
  private subscriptions: Map<string, WebSocketSubscription> = new Map();
  public messages$ = new Subject<WebSocketEvent<RoomInfoDto | GameStateDto>>();
  private connectionStatus$ = new BehaviorSubject<boolean>(false);
  private reconnectAttempts = 0;
  private readonly MAX_RECONNECT_ATTEMPTS = 5;
  private readonly RECONNECT_BACKOFF_MAX_MS = 30000; // Max 30 seconds between retries
  private readonly ROOM_TOPIC_PREFIX = '/topic/rooms/';
  private readonly GAME_TOPIC_PREFIX = '/topic/game/';
  private readonly MAX_RECONNECT_ATTEMPTS = 5;
  private readonly RECONNECT_BACKOFF_MAX_MS = 30000; // Max 30 seconds between retries
  private readonly ROOM_TOPIC_PREFIX = '/topic/rooms/';
  private readonly GAME_TOPIC_PREFIX = '/topic/game/';

  constructor(private auth: AuthService) {}


  /**
   * Connect to a game room's WebSocket topic
   * Follows the backend's /topic/rooms/{roomCode} pattern
   */
  connectToRoom(roomCode: string): void {
    if (!roomCode) {
      console.error('[WebsocketService] Room code is required');
      return;
    }
    const topic = `${this.ROOM_TOPIC_PREFIX}${roomCode}`;
    this.connectAndSubscribe(topic, 'room');
  }

  /**
   * Connect to a game's WebSocket topic for a specific user
   * Follows the backend's /topic/game/{gameId}/user/{userId} pattern
   */
  connectToGame(gameId: string, userId: string): void {
    if (!gameId || !userId) {
      console.error('[WebsocketService] Game ID and User ID are required');
      return;
    }
    const topic = `${this.GAME_TOPIC_PREFIX}${gameId}/user/${userId}`;
    this.connectAndSubscribe(topic, 'game');
  }

  /**
   * Initiates WebSocket connection with token validation
   * @param topic The WebSocket topic to subscribe to
   * @param type The type of topic (room or game)
   */
  private connectAndSubscribe(topic: string, type: TopicType): void {
    // Always use AuthService for token
    const token = this.auth.getAccessToken();
    if (!token) {
      console.warn('[WebsocketService] No token found, refreshing...');
      this.refreshAndConnect(topic, type);
      return;
    }

    try {
      const payload = this.validateTokenPayload(token);
      const now = Math.floor(Date.now() / 1000);
      
      if (!payload || payload.exp < now) {
        console.warn('[WebsocketService] Token invalid or expired, refreshing...');
        this.refreshAndConnect(topic, type);
      } else {
        this._connectWithTokenAndSubscribe(topic, token, type);
      }
    } catch (e) {
      console.error('[WebsocketService] Token validation error:', e);
      this.refreshAndConnect(topic, type);
    }
  }

  /**
   * Validates and decodes a JWT token payload
   * @param token The JWT token to validate
   * @returns Decoded token payload or null if invalid
   */
  private validateTokenPayload(token: string): any | null {
    try {
      const parts = token.split('.');
      if (parts.length !== 3) {
        console.error('[WebsocketService] Invalid token format');
        return null;
      }
      return JSON.parse(atob(parts[1]));
    } catch {
      return null;
    }
  }

  /**
   * Refreshes token and attempts to reconnect
   * Handles failed refresh attempts with reconnection strategy
   */
  private refreshAndConnect(topic: string, type: TopicType): void {
    this.auth.refreshToken().subscribe({
      next: (freshToken: string) => {
        if (!freshToken) {
          console.error('[WebsocketService] Token refresh failed - empty token');
          this.handleReconnect(topic, type);
          return;
        }
        
        const payload = this.validateTokenPayload(freshToken);
        if (!payload) {
          console.error('[WebsocketService] Token refresh failed - invalid token');
          this.handleReconnect(topic, type);
          return;
        }

        console.log('[WebsocketService] Token refreshed successfully');
        this._connectWithTokenAndSubscribe(topic, freshToken, type);
      },
      error: (err) => {
        console.error('[WebsocketService] Token refresh error:', err);
        this.handleReconnect(topic, type);
      }
    });
  }

  /**
   * Establishes STOMP client connection with token
   * Handles connection lifecycle and error cases
   */
  private _connectWithTokenAndSubscribe(topic: string, token: string, type: TopicType): void {
    if (!token) {
      console.error('[WebsocketService] Cannot connect: No token provided');
      return;
    }

    const base = environment.apiUrl.replace(/\/$/, '');
    const wsUrl = `${base.replace(/^http/, 'ws')}/ws?token=${encodeURIComponent(token)}`;
    
    if (!this.stompClient) {
      try {
        this.stompClient = new Client({
          brokerURL: wsUrl,
          reconnectDelay: 5000,
          heartbeatIncoming: 4000,
          heartbeatOutgoing: 4000,
          debug: (msg: string) => {
            if (environment.production) return;
            console.debug('[STOMP]', msg);
          }
        });

        this.stompClient.onConnect = (frame: IFrame) => {
          console.log('[WebsocketService] STOMP connection established');
          this.connectionStatus$.next(true);
          this.reconnectAttempts = 0;
          
          // Clear existing subscriptions
          this.cleanupSubscriptions();
          
          // Subscribe to the new topic
          this._subscribeToTopic(topic, type);
        };

        this.stompClient.onStompError = (frame: IFrame) => {
          console.error('[WebsocketService] STOMP protocol error:', frame);
          const msg = frame.headers?.['message'] ?? '';
          
          if (msg.includes('expired') || msg.includes('invalid')) {
            this.handleTokenError(topic, type);
          } else {
            console.error('[WebsocketService] Unhandled STOMP error:', msg);
            this.handleReconnect(topic, type);
          }
        };

        this.stompClient.onWebSocketError = (event: Event) => {
          console.error('[WebsocketService] WebSocket error:', event);
          this.handleReconnect(topic, type);
        };

        this.stompClient.onDisconnect = () => {
          console.log('[WebsocketService] STOMP client disconnected');
          this.connectionStatus$.next(false);
        };

        this.stompClient.activate();
      } catch (err) {
        console.error('[WebsocketService] Failed to create STOMP client:', err);
        this.handleReconnect(topic, type);
      }
    } else {
      // Already have a client, just subscribe to topic
      this._subscribeToTopic(topic, type);
    }
  }

  /**
   * Handles token-related errors by attempting refresh
   */
  private handleTokenError(topic: string, type: TopicType): void {
    this.auth.refreshToken().subscribe({
      next: async (freshToken: string) => {
        if (!this.validateTokenPayload(freshToken)) {
          console.error('[WebsocketService] Received invalid token during refresh');
          this.handleReconnect(topic, type);
          return;
        }

        if (this.stompClient) {
          await this.stompClient.deactivate();
          this.stompClient = null;
        }
        
        this._connectWithTokenAndSubscribe(topic, freshToken, type);
      },
      error: (err) => {
        console.error('[WebsocketService] Token refresh failed:', err);
        this.handleReconnect(topic, type);
      }
    });
  }

  /**
   * Cleans up existing subscriptions before reconnecting
   */
  private cleanupSubscriptions(): void {
    for (const [topic, sub] of this.subscriptions.entries()) {
      try {
        if (sub?.subscription) {
          sub.subscription.unsubscribe();
        }
      } catch (err) {
        console.warn('[WebsocketService] Error unsubscribing from topic:', topic, err);
      }
    }
    this.subscriptions.clear();
  }

      this.stompClient.activate();
    } else {
      // Already connected, just subscribe to topic
      this._subscribeToTopic(topic, type);
    }
  }

  private handleReconnect(topic: string, type: TopicType): void {
    this.connectionStatus$.next(false);
    if (this.reconnectAttempts < this.MAX_RECONNECT_ATTEMPTS) {
      this.reconnectAttempts++;
      console.log(`[WebsocketService] Attempting reconnect ${this.reconnectAttempts}/${this.MAX_RECONNECT_ATTEMPTS}`);
      setTimeout(() => {
        this.connectAndSubscribe(topic, type);
      }, 5000 * this.reconnectAttempts);
    } else {
      console.error('[WebsocketService] Max reconnection attempts reached');
    }
  }

  private _subscribeToTopic(topic: string, type: TopicType): void {
    if (!this.stompClient) {
      console.error('[WebsocketService] No STOMP client available');
      return;
    }

    // Check if already subscribed
    if (this.subscriptions.has(topic)) {
      console.log('[WebsocketService] Already subscribed to:', topic);
      return;
    }

    // Create new subscription with type-safe message handling
    const subscription = this.stompClient.subscribe(topic, (message: IMessage) => {
      try {
        const parsed = JSON.parse(message.body);
        
        // Type-guard the message based on topic type
        if (type === 'room') {
          const roomMessage: WebSocketEvent<RoomInfoDto> = {
            type,
            payload: parsed as RoomInfoDto
          };
          this.messages$.next(roomMessage);
          console.log('[WebsocketService] Room update:', roomMessage.payload);
        } else {
          const gameMessage: WebSocketEvent<GameStateDto> = {
            type,
            payload: parsed as GameStateDto
          };
          this.messages$.next(gameMessage);
          console.log('[WebsocketService] Game state update:', gameMessage.payload);
        }
      } catch (e) {
        console.error('[WebsocketService] Message parse error:', e, message.body);
      }
    });

    // Store subscription with metadata
    const wsSubscription: WebSocketSubscription = {
      topic,
      subscription,
      type
    };
    
    this.subscriptions.set(topic, wsSubscription);
    console.log(`[WebsocketService] Subscribed to ${type} topic:`, topic);
  }

  disconnectTopic(topic: string): void {
    const sub = this.subscriptions.get(topic);
    if (sub?.subscription) {
      sub.subscription.unsubscribe();
      this.subscriptions.delete(topic);
      console.log('[WebsocketService] Disconnected from topic:', topic);
    }

    // If no more subscriptions, disconnect client
    if (this.subscriptions.size === 0 && this.stompClient) {
      console.log('[WebsocketService] No more subscriptions, deactivating client');
      this.stompClient.deactivate();
      this.stompClient = null;
      this.connectionStatus$.next(false);
    }
  }

  send(destination: string, data: any): void {
    if (!this.stompClient?.connected) {
      console.error('[WebsocketService] Cannot send message: not connected');
      return;
    }

    try {
      this.stompClient.publish({
        destination,
        body: JSON.stringify(data)
      });
      console.log('[WebsocketService] Sent message to:', destination);
    } catch (e) {
      console.error('[WebsocketService] Error sending message:', e);
    }
  }

  disconnect(): void {
    console.log('[WebsocketService] Disconnecting all subscriptions');
    
    // Unsubscribe from all topics
    for (const [topic, sub] of this.subscriptions.entries()) {
      if (sub?.subscription) {
        sub.subscription.unsubscribe();
        console.log('[WebsocketService] Unsubscribed from:', topic);
      }
    }
    this.subscriptions.clear();

    // Deactivate STOMP client
    if (this.stompClient) {
      this.stompClient.deactivate();
      this.stompClient = null;
      console.log('[WebsocketService] STOMP client deactivated');
    }

    this.connectionStatus$.next(false);
  }

  ngOnDestroy(): void {
    this.disconnect();
    this.messages$.complete();
    this.connectionStatus$.complete();
  }

  getConnectionStatus(): Observable<boolean> {
    return this.connectionStatus$.asObservable();
  }

  // getToken() is now obsolete; use AuthService.getValidAccessToken()
}
